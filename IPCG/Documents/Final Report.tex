\documentclass[a4paper,oneside,12pt,openany]{memoir}
\chapterstyle{section}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage[left=35mm, right=24mm, top=24mm, bottom=24mm]{geometry}
\setlength{\beforechapskip}{0cm}
\setlength{\afterchapskip}{0.5cm}
\setlength{\parindent}{0cm}
\setlength{\parskip}{0.4cm}
\setcounter{tocdepth}{3}
\maxsecnumdepth{subsection}
\tightlists
\renewcommand{\bibname}{References}
\renewcommand*{\cftappendixname}{\appendixname~}
\renewcommand{\cftchapteraftersnum}{:}
\begin{document}
\frontmatter
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}

{\Large \textsc{Electronics and Computer Science}} \\[0.3cm]
{\Large Faculty of Physical and Applied Sciences} \\[0.3cm]
{\Large University of Southampton} \\[2cm]

{\Large Thomas A. E. Smith} \\[0.2cm]
taes1g09@ecs.soton.ac.uk\\[0.3cm]
{\large \today} \\[1.5cm]

\textbf{\LARGE Intelligent Procedural Content\\[0.2cm] Generation for Computer Games} \\ [5cm]
% \end{center}
\begin{tabular}{r@{  --  }l}
{\Large Project supervisor: E. Gerding }&{\Large eg@ecs.soton.ac.uk} \\[0.3cm]
{\Large Second examiner: C. Cirstea}&{\Large cc2@ecs.soton.ac.uk} \\
\end{tabular}
\\[1.5cm]
% \begin{center}
{\large A project report submitted for the award of} \\[0.3cm]
{\large MEng Computer Science with Artificial Intelligence}

\end{center}
\vspace*{\fill}

\pagebreak
\vspace*{\fill}
\begin{abstract} %not more than 200 words
Increasingly, as the demand for ever larger and more varied computer game environments grows, procedural content generation (PCG) is used to ensure that content remains `fresh'. However, many of the opportunities to use these systems to generate truly personalised content have so far been largely overlooked. When content is generated manually or algorithmically during the design phase of a game, it can only be created according to the designers' expectations of the players' needs. By instead generating content during the execution of the game, and using information about the player(s) as one of the system's inputs, PCG systems should be able to produce more varied content that can be far more tailored to enhance individual players' experiences than anything manually created. Much has been written about the generation of player models from observed data, including for the purposes of adaptivity or dynamic difficulty adjustment (DDA), and literature exists examining the problem of generating satisfying game environments via challenge adjustment. This project looks at combining these fields to create an intelligent PCG system (IPCG) that is capable of monitoring players' progress and dynamically generating upcoming challenges to best suit their abilities. TODO: specify that this is a prototype, investigating a specific aspect of the many that IPCG is able to cover.
\end{abstract}
\vspace*{\fill}
\vspace*{\fill}
\pagebreak

\tableofcontents*
% \pagebreak

\chapter{Statement of Originality}
- You are strongly encouraged to include a one or two paragraph statement of originality
– “this is all my own work” is rarely true
– you should acknowledge the help you have received
- Was the idea for the project yours, or was it based on an earlier project, or your supervisor’s research?
- The examiners will assume that the analysis, design, implementation, testing, \ldots are your own work
- So tell them where this is not true
– the design of component X follows a standard technique/pattern described in [source]
– this is my own code except for <package/class/method> which I have copied from <Internet site/author>

\mainmatter

\chapter{Project Description}
\section{Introduction}
%1. Introduction describing the problem
%- A clear statement of the problem and goals of the project
%– project goals
The aim of this project is to investigate the use of intelligent procedural content generation (IPCG) in computer games, by looking at existing products, research in related areas and constructing a minimal prototype. <TODO: explanation of IPCG> Due to the increasing demand for both detail and variety within computer game environments, various aspects of in-game content are now often generated procedurally (that is, algorithmically rather than manually), using techniques that are frequently just refinements of algorithms used in the early days of computing, for games such as Elite or Nethack.%\cite{elite}.
However, one of the strengths of modern procedurally generated content (PCG) is that (within reasonable limits) it may be performed at runtime, allowing it to also use information about the player in order to dynamically generate content on-the-fly in response to the player's actions. In general, this will involve making use of algorithms from the field of Artificial Intelligence in order to evaluate the information available and condense it to a form suitable for input to a PCG system; hence such systems might reasonably be termed `intelligent' procedural content generators (IPCG).
As shown later in the literature review and background research sections, IPCG techniques can be applied to many different scenarios, for many reasons. For the purposes of this project, the prototype will be restricted to using IPCG for dynamic difficulty adjustment (DDA) in basic 2D platformer levels.
\subsection*{Definitions:}
\subsubsection{Procedural Content Generation}
\subsubsection{Dynamic Difficulty Adjustment}
\subsubsection{Intelligent Procedural Content Generation} 
\section{Literature and Existing Systems}
\section{Prototype}
\section{Goals}

\chapter{Project Background}
% 2. a chapter reviewing approaches/literature
% - A review of the background literature
Lot of academic work in related fields
Paucity of actual shipping systems
\section{Procedural Content Generation}
Procedural Content Generators have been used since the early days of gaming. Well-known games such as Elite and Rogue made extensive use of PCG in order to present the player with expansive game worlds far larger than could have been fully stored on the distribution media that was available at the time. As technologies improved, focus shifted more towards hand-crafted environments as it was easier to ensure that these provided value and did not feel sparse \cite{charbitat}. However, with the further progress of technology attention has returned to procedural generation. Modern game worlds contain vast amounts of detail, and procedural content generation algorithms are ideally suited to producing large numbers of variations on a theme, be that trees, clouds, textures, or even sounds. Producing each of these items individually by hand would take many hours of labour and much disk space, but by defining specific sub elements and assembly rules, variation can be almost endlessly reused, as in the game Infinite Mario.%\cite{mario}.
TODO: mention occupancy regulated expansion / extension

\subsection{Existing PCG Systems}

\section{Dynamic Difficulty Adjustment}
Another game design concept receiving increasing attention is dynamic difficulty adjustment (DDA). Typically, challenge adjustment within video games has consisted of user choice between one or more discrete challenge settings that have been painstakingly balanced at production time. However, this solution is far from ideal - typically, if a game is begun with a certain difficulty it is difficult to later change; and this upfront decision also alienates players that are unfamiliar with the terminology or expectations, or uncertain how to classify themselves\cite{5765665}. Furthermore, since game difficulty is typically a continuous function of multiple parameters, it should be possible to precisely match each player to their ideal level of challenge rather than enforcing adherence to low-resolution skill profiles. Typically, DDA is achieved by altering values that are hidden from the player, such as enemy health, accuracy, or the amount of ammo and health-kits available in the world \cite{hamlet}. Often, the intention is to do this invisibly, and merely ensure that the player remains optimally challenged. By manipulating values behind the scenes, it is possible to ensure that the player is neither overchallenged (leading to frustration), or underchallenged (leading to boredom)\cite{flow}. As DDA systems are given more control over additional aspects of the game environment, they can begin to enter the realm of PCG, fundamentally altering the structure and pacing of the player's experience. 
\subsection{Existing DDA systems}

\section{Intelligent Procedural Content Generation}
\subsection{Existing IPCG Systems}
IPCG can be (and has been) used for a wide range of purposes, almost as varied as PCG itself. Three very different such uses are detailed below. It is unsurprising that many of the existing applications of IPCG are used to tackle some of the current key challenges in game design: maintaining players' engagement with the game via enhancing immersion and controlling flow\cite{flow}. 
\subsubsection{Valve's `AI Director'}
One of the most well-known such applications is used in Valve's games Left 4 Dead and Left 4 Dead 2. Known as the `AI Director', the system monitors the ``emotional intensity'' of each players' gameplay experience, and dynamically alters the placement of supplies and the generation of enemies of various types in order to control pacing and maintain flow. In Left 4 Dead 2, the Director has additional control over the structure of the level\cite{valve}.
\subsubsection{Bethesda's Radiant Story}
Another recent example of IPCG is the Radiant Story system used in Bethesda's Skyrim. Rather than monitor the player's performance, it evaluates their progress and history, and deliberately generates in-game tasks designed to force exploration of previously unknown areas; in order to increase immersion.%\cite{radiant}. 
\subsubsection{GAR's Weapon Evolution}
Finally, the weapon evolution mechanism in the game Galactic Arms Race\cite{garmsr} is an unconventional application of an IPCG system, as it tracks only which weapons the players prefer, and then uses small neural networks to evolve new variations on the favourite weapons, which themselves are all simply procedurally generated particle systems\cite{Hastings:2009:IEP:1650356.1650369}.


\section{Problem Specification}
An analysis and specification of the solution to the problem

% \section{lit review}
Though mechanisms fulfilling the definitions of IPCG systems have already started appearing in games, little has so far been written specifically on the subject - ``personalized and player-adaptive PCG \ldots is a new research direction''\cite{shaker2010towards}. However, existing literature in related areas borders on the topic: in some cases DDA algorithms are being used to generate entire levels; thus qualifying as IPCG. One of the most thorough papers on this area is ``Polymorph: Dynamic Difficulty Adjustment Through Level Generation'', by Jennings-Teats \emph{et al.} \cite{polymorph}, which generates 2D platformer levels on-the-fly. Approaching the topic of IPCG from another direction, Lopes' and Bidarra's ``Adaptivity Challenges in Games and Simulations: A Survey'' investigates the use of adaptivity in general in order to combat static and predictable content\cite{5765665}, including via PCG.

\subsection{Polymorph: DDA Through Level Generation}
%alters game during play, intensive more than jsut tweaking pervasive across level disign/stucture. Level generation and machine learning to understand component difficulty an player skill. 2D platformer with on-the-fly. Statistical model of difficulty in the level along with model of players current skill level. Machine learning from play traces from 'game-like tool'. This is an advance on prior work in dynamic difficulty adjustment, which has for the most part avoided adaptive level design, and in procedural level generation, which has mainly focused on creating full levels for replayability. Design for flow. Balancing takes effort. not possible 100\% coverage. DDA is typically numeric. this structural. Infinite mario not fly, this is. PCG typically more granular. rhythm. data collection tool. recognise shortcomings - and skew: critic modules. learn ranking - combination of component difficultie
Polymorph is a progression of prior work in both DDA and PCG: like previous DDA systems it alters challenge during play, and as with traditional PCG for 2D platformers it generates levels algorithmically. However, the DDA is effected via structural differences in the level design rather than `numerical tweaking', and the level is generated `online' out of small rhythm segments\cite{Smith:2009:RLG:1536513.1536548}, rather than fully ahead of time. The authors present an interesting statistical model of difficulty, along with some of the issues and solutions found while evaluating the system.
 \cite{polymorph}
\subsection{Adaptivity Challenges in Games and Simulations: A Survey}
% purposes: against static. worlds, scenarios and quests. low resolution stereotypes. indiviuality, diferent needs/desires. player-centered adaptivity. go beyond challenge as a steering purpose. training?. Purpose, then targets. traditionally AI
The survey is an investigation of present research into and existing commercial implementations of adaptivity in games. The topic is broken down into three areas: purpose, target and method, with a wide range of examples given for each point raised. In contrast to other papers on the subject, the authors look beyond challenge as the sole steering purpose for adaptivity, and then discuss the wide range of types of content that may be adapted or generated algorithmically. Finally, they look at the methods by which content may be adapted or generated, and conclude that PCG is one of the most promising for offline generation, and also may increasingly be suited to online adaptation.
\cite{5765665}


\chapter{Proposed System}
% 3. a chapter introducing final approach
% - An analysis and specification of the solution to the problem
% – detailed requirements
\section{Overview}
Following the separation of concerns (SoC) design practice, the project may easily be modularised into three principle components: a `host' or base module, an adaptive PCG system, and a means of taking data about the player and converting it into a model usable by the PCG. The proposed flow of information is shown in \fref{Figure:dataflow}.

\begin{figure}[htbp]
  \centering
  \includegraphics[trim = 10mm 12mm 10mm 12mm, clip]{system}
  \caption{Data flow in proposed system.}
  \label{Figure:dataflow}
\end{figure}
\subsection{Modules}
\subsubsection{Game Base}
A simple 2D platformer engine. This module should handle all input and rendering activity, and should follow the MVC architecture. In addition to presenting the user with the output of the IPCG system, the Base module should provide the basic input handling, physics and game functionality necessary to play the platformer, while also logging multiple types of information about the players performance for the Evaluator module. 
\subsubsection{Adaptive PCG}
An adaptable 2D platforming level generator. Building on the work of Compton \emph{et al.}\cite{compton2006procedural}, this module should maintain a context-free grammar (CFG) of obstacles available, along with weights representing the estimated challenge of each element (terminal obstacle or combination). By taking these weights into account when deriving a string of obstacles from the CFG, sequences of a desired difficulty can be produced - or alternatively, the estimated challenge of existing sequences may be evaluated. A PCG system designed in this way should be able to generate entire levels `offline', by maintaining pre-determined maxima and local variations in difficulty, but should also be capable of generating levels on-the-fly, by ensuring that short-term future difficulty levels match those requested by the Evaluator.
\subsubsection{Player Evaluator}
Initially, a multi-class classifier. Given the varied inputs from the Base module, the Evaluator should form a belief about the player's skill relative to the current challenge of the level. By running the player's data through a previously-trained classifier, this module should obtain a model that can be passed to the PCG module and acted upon.
\subsection{Approach}
The modules above are presented in logical order of development: none of the IPCG system will be testable without the Base program (which can be tested standalone if given a hand-crafted level), but the PCG may be run and tested using specimen models, and finally the Evaluator can be tested once the other systems are in place.
\subsubsection{Classifier Training}
 The development of the classifier will involve initially collecting data on as many potentially relevant features of the player's performance as possible, and then performing principle component analysis (PCA) upon the data-set in order to identify the maximally variant features. These can then be retained and used as the input to a K-means discretisation algorithm, which can finally be used to train a One-vs-All SVM classifier. 
\subsection{Justification}
An alternative approach to the problem of generating a 2D platforming environment for use with DDA is presented by Sorenson \emph{et al.}\cite{5940995}, who detail a more general top-down approach using genetic algorithms. However, their system is also more complex and provides an unneeded degree of generality for this project. This system as proposed should be able to fulfill the requirements given, and demonstrate intelligent variation in output based upon the skill of the player.
TODO: mention the other student's one, with cannons 

\section{Requirements}
The main aim of the project requirements will be to constrain the problem to an achievable scale, and inform future evaluation of the final solution. In this instance, the functional requirements are generic to any IPCG system (with refinements specific to this problem in brackets, like so), while the non-functional requirements are constraints that should serve to encourage feasibility and quality.

\subsection{Functional}
In order to properly implement IPCG, the system should:
\begin{itemize}[-]
\item present the user with an interactive game environment (basic 2D platformer)
\item record data on the player's behaviour (in this case, performance)
\item evaluate this data according to specific criteria (a trained classifier)
\item form a model of some aspect of the player (skill relative to current difficulty)
\item use this model to inform further PCG activities (level chunk generation)
\end{itemize}

\subsection{Non-Functional}
In order to remain at a manageable scale, the system should:
\begin{itemize}[-]
\item be written in Java
\item be confined to 2D
\item be presented as a basic platformer
\item limit the user to move and jump actions
\end{itemize}
but also:
\begin{itemize}[-]
  \item remain responsive
  \item properly maintain the challenge of generated content
\end{itemize}
TODO: make this FAR longer and more detailed.
 Write about evaluation method using swing
 
% 4... further chapters discussing system implementation or experiment...
\chapter{System Design}
% - A detailed design
% – high level design or architecture
% – comparison of alternative technologies

o Which process did you follow: – waterfall, iterative, evolutionary?
o How does this show in your plan? 
o Why did you choose this process? 
o How well did it work out for you?

TODO: mention Java

\chapter{System Implementation}
% - The implementation
see testing


\chapter{System Testing}
% - Testing strategy and results
see appendix 

\chapter{System Evaluation}
% n-1. a chapter reviewing progress and results
% - A critical evaluation
% – measurements
o Comparative evaluation(cf.competition) 
– performance graphs, feature lists
o Criticalevaluation
– with respect to your project goals and plan

\chapter{Project Evaluation}
% – comparative and critical evaluation – reflection
One or more Gantt charts showing the planned schedule and the actual progress

o Criticalevaluation
– with respect to your project goals and plan
o Reflection
– in hindsight, did you use the right tools, techniques, metrics and methods?
– what did you learn?
– were your goals and plan sensible?
– how could you have done it better/differently?

Project Management and Planning
o You should account for your time
– this is the major expense for most projects
o Compare your initial plan with how things actually went
– perhaps include project diary as an appendix
o If you fell behind how did you catch up – or decide which features to drop
o Did you consider and allow for risks – illness, equipment failure or delays

\begin{figure}[ht]
\begin{minipage}[b]{0.5\linewidth}
\centering
\vspace{-5cm}
\section{Gantt Charts}

\addcontentsline{toc}{section}{5.1 Work Completed}
\addcontentsline{toc}{section}{5.2 Work Remaining}

     \includegraphics[scale=0.7, trim = 12mm 30mm 95mm 30mm, clip]{done}
\caption{Work Completed}
\label{fig:figure1}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
  \includegraphics[scale=0.5, angle=90, trim = 36mm 0mm 0mm 0mm, clip]{todo}
\caption{Work Remaining}
\label{fig:figure2}
\end{minipage}
\end{figure}


\chapter{Conclusion}
% n. Conclusion and proposal of further work and ideas
% - Conclusions and future work
% – future work
% – summary and conclusions
\section{Possible Extensions}
One drawback of the system as proposed is that it must still reduce all of the data about the player's performance into a single discrete decision: whether to continue generating the level at the current difficulty, increase the difficulty, or decrease it. There is no opportunity for granularity representing player aptitude at a particular type of challenge. One possible extension would be to divide the obstacles by type (stationary hazard, timed hazard, projectile etc.), and evaluate the player's skill on particular classes individually, then use this more detailed model to inform a slightly more sophisticated PCG module. This approach would be an ideal candidate for a collaborative filtering algorithm, which with a large enough dataset would further allow the system to predict a player's aptitude at obstacle types that had not yet been seen by that player.



\bibliography{IPCG}{}
\bibliographystyle{plain}

\appendix
% \appendixpage
% \addappheadtotoc
\addcontentsline{toc}{chapter}{Appendices:}

\renewcommand{\printchaptername}{\chapnamefont\appendixname }
\renewcommand{\chapternamenum}{ }
\renewcommand{\printchapternum}{\chapnumfont \thechapter: }
%   \renewcommand{\afterchapternum}{: }

\chapter{Project Brief}
% \include{Project Brief}


% \documentclass[12pt]{article}
% %\usepackage{a4wide}
% %\usepackage[small,compact]{titlesec}
% \usepackage[parfill]{parskip}
% \date{}
% %\raggedbottom
% \thispagestyle{empty}
% \setlength{\topmargin}{-0.2in}
% \setlength{\textheight}{8.7in} 
% \begin{document}
\begin{center}
{\LARGE Intelligent Procedural Content Generation\linebreak for Computer Games}


Thomas Smith \linebreak
\textbf{Supervisor:} Enrico Gerding
\end{center}

\textbf{Problem:} In modern computer game development, content production accounts for a large proportion of the initial (and in some cases, ongoing) outlay. As both budgets and in-game worlds get larger, there is increasing demand to offload some of these production efforts to automated systems. The concept of procedural content generators (PCG) has been around for some time, and they have been used in many successful games, but many of the advantages made available by these systems have so far been largely overlooked. When content is generated manually or algorithmically during the design phase of a game, it can only be created according to the designer's expectations of the players' needs. By instead generating content during the execution of the game, and using information about the player(s) as one of the system's inputs, PCG systems should be able to produce more dynamic experiences that can be far more tailored to enhance individual player's experiences than anything manually created. An intelligent procedural content generator (IPCG) should therefore consist of two parts: some means of evaluating (some aspect of) the player and generating a model, and a PCG system that is able to accept this model as an input and dynamically generate variants on its standard output based on the contents of the model.

%PCG
%There are several reasons for which we may wish to dynamically adjust the content provided by the IPCG systems, based on different aspects of the player. We may want to ensure that 

\textbf{Goals:} As specified above, an intelligent PCG should consist of two subsystems: an evaluator and its companion generator. The aim of the project will be to create a simple game-like application that uses an IPCG system to produce dynamically variable content based on the player's behaviour. I will begin by creating a variable PCG that is able to produce content based on specimen player models, and then use environments created in this way to create and tune a player evaluator for further generation.

\textbf{Scope:} In order to attempt to ensure that the project goals remain achievable, the scope should be restricted to the simplest possible system. Based on inital inspection of the problem space and existing literature, it appears that this would be adjustment due to player skill in a 2D platforming environment. The project will be coded in Java, as that comprises the majority of my recent coding experience, and it has a wealth of 2D graphics drawing support which will simplify the less-relevant areas of coding. Similarly, many of the peripheral components traditionally included in computer games are irrelevant to the project and will not be needed.
%Given that the majority of my recent coding experience is in Java, and the wealth of 2D graphics support in Java, 
% \end{document}


\chapter{Questionnaire Script}
\textit{These questions will be presented to participants during the course of the experiment:}
\\
\\

\textit{1) At the start of the experiment, rating agreement on a 5-point Likert item:}

\textbf{I am familiar with videogames in general.}

\begin{tabularx}{\linewidth}%
 {>{\raggedright}X%
  >{\centering}X%
  >{\raggedleft}X}
strongly~disagree & neutral & strongly agree\tabularnewline
\end{tabularx}
\begin{tabularx}{\linewidth}%
 {>{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X}
$\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$
\end{tabularx}
\\

\textbf{I am familiar with 2D platforming games.}

\begin{tabularx}{\linewidth}%
 {>{\raggedright}X%
  >{\centering}X%
  >{\raggedleft}X}
strongly~disagree & neutral & strongly agree\tabularnewline
\end{tabularx}
\begin{tabularx}{\linewidth}%
 {>{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X}
$\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$
\end{tabularx}
\\
\\
\\

\textit{2 –- 5) After each of the four interactive sections, evaluating the previous section on a 7-point Likert item:}

\textbf{The previous level presented a level of challenge that was:}

\begin{tabularx}{\linewidth}%
 {>{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X%
  >{\centering}X}
   too easy & & & about~right & & & too hard\tabularnewline
$\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$ & $\circ$
\end{tabularx}
\\
\\
\\

\textit{6) At the end of the experiment:}

\textbf{This data has been collected during the course of this session:}

\begin{tabular}{|l|}
\hline
\texttt{< collected data >}\\
\\
\\
\hline
\end{tabular}


\fbox{Submit $>>$}

\chapter{DVD Contents}
%  - A software project, or a project with a significant software component should include a CD or DVD at the back of the report with the sources and executables. A short table of contents for the CD/DVD should be included as a printed appendix.
 
\end{document}

The main body of the report must not exceed 10,000 words. This is about 30 A4 pages of standard-spaced text, although display material such as diagrams and equations may add slightly to the page count.

The final report should provide:

A clear statement of the problem and goals of the project
A review of the background literature
An analysis and specification of the solution to the problem
A detailed design
The implementation
Testing strategy and results
A critical evaluation
Conclusions and future work
References to the literature
Appendices providing detailed technical references
The final report should document the project planning. In particular it should compare the project plans set out in the project brief and progress report with the actual achievements. To this end it should include the following:

A copy of the original project brief as an appendix
One or more Gantt charts showing the planned schedule and the actual progress
The report comprises a main body together with appendices. The appendices may contain a user manual, circuit diagrams etc. and support the main text. The nature and extent of the appendices will depend on the type of project undertaken and must be agreed in advance with the project supervisor. The text in the appendices is not included in the word limit.

Title page
Abstract
Contents list
Acknowledgments and Statement of Originality
1. Introduction describing the problem
- A clear statement of the problem and goals of the project
– project goals
2. a chapter reviewing approaches/literature
- A review of the background literature
3. a chapter introducing final approach
- An analysis and specification of the solution to the problem
– detailed requirements
4... further chapters discussing system implementation or experiment...
- A detailed design
– high level design or architecture
– comparison of alternative technologies
- The implementation
- Testing strategy and results
n-1. a chapter reviewing progress and results
- A critical evaluation
– measurements
– comparative and critical evaluation – reflection
n. Conclusion and proposal of further work and ideas
- Conclusions and future work
– future work
– summary and conclusions
References
- References to the literature
Appendices
- Appendices (if needed)
 - A software project, or a project with a significant software component should include a CD or DVD at the back of the report with the sources and executables. A short table of contents for the CD/DVD should be included as a printed appendix.
 



o A justified approach
– alternatives, feature list, selection, known-
good practice
o Claims supported by evidence
– measurements, audit trail, log book
o Appropriate use of tools, techniques, metrics and methods
– fit for purpose (engineering perspective) 
– to gain marks (educational perspective)


o Comparative evaluation(cf.competition) 
– performance graphs, feature lists
o Criticalevaluation
– with respect to your project goals and plan
o Reflection
– in hindsight, did you use the right tools, techniques, metrics and methods?
– what did you learn?
– were your goals and plan sensible?
– how could you have done it better/differently?

Project Management and Planning
o You should account for your time
– this is the major expense for most projects
o Compare your initial plan with how things actually went
– perhaps include project diary as an appendix
o If you fell behind how did you catch up – or decide which features to drop
o Did you consider and allow for risks – illness, equipment failure or delays


BCS Requirements
o theproblem&theobjectivesoftheproject
o reviewofthecontext/literature/competition
o thelife-cyclestagesundertaken
o thedevelopmenttoolsused
o useofV&Vateachstage
o rationale for design/implementation decisions
o criticalevaluation,reviewoftheplan&any deviations from it, lessons learnt

Appropriate tools: Mercurial for source control, LucidChart for planning, Eclipse IDE

Need to write about testing. Collision system was TDD

o Interestingorimportantdatastructures
o Use pseudo-code or an activity diagram, but not flow charts, to explain interesting or important algorithms
– EL students may use ASM charts, however
o Use/reuseofclasslibrariesorcomponents
o Justifieduseoftrendytechnologies
– XML, web services, RSS, AI, encryption,\ldots
o Anyinterestingorsignificanterrors – how you located and corrected them

Metrics
o Simple counts: LOCs, classes, methods, features implemented
o OO metrics: methods/class, coupling
o Test coverage: branches/methods executed
o Execution time (and complexity?)
o Memory usage (and complexity?)
o Achievement: tests passed, features delivered
o Satisfaction: end-user questionnaires
– appropriate descriptive/analytical statistics

o Which process did you follow: – waterfall, iterative, evolutionary?
o How does this show in your plan? 
o Why did you choose this process? 
o How well did it work out for you?

M Very good planning, progress, time management, and contingency planning
Detailed analysis of requirements, costs and benefits; very well designed and
T implemented; use of simulation/modelling/prototyping and a range of tools and
techniques
E Very good testing, critical and comparative evaluation and reflection
A Significant achievement and results; innovation and creativity; worthy of utilisation
Very well written, structured & formatted, review of related work including research papers
U Viva/demo and report shows good knowledge and understanding

\end{document}
